# Request Handler

Every application, no matter how elegant its internal logic, eventually has to deal with the messy, unpredictable outside world. This module is the system's front door, responsible for translating the chaotic symphony of HTTP requests into something the rest of the framework can understand and act upon. It listens for network traffic, wraps it in a semblance of order, and broadcasts it into the system, which then processes it in a series of carefully orchestrated phases.

-----

## Core Concepts

The request handling mechanism is built on a few core principles designed to decouple the web layer from the business logic. It's a classic separation of concerns, which is a fancy way of saying we build walls between things so that when one part inevitably breaks, it doesn't take everything else down with it.

### \#\#\# HTTP Server & Routing

At its heart, **`BaseRequestHandler`** runs a standard Node.js `http.Server`. It acts as a bouncer, immediately passing an incoming URL to the **`BaseRouter`**. The router can be configured to rewrite public-facing URLs (e.g., `/profile`) to different internal paths before any further processing happens, providing a useful layer of abstraction.

### \#\#\# The Request as a Phased Event

This is the critical part. The **`BaseHttpContext`** translates an incoming HTTP request into a system-wide **event topic**. This topic is structured very specifically: `/request/{contextId}/{httpMethod}{path}`. For example, a `POST` request to `/users/create` becomes a topic like `/request/abc123/post/users/create`.

The context then triggers the execution of all registered actions that match this topic. Crucially, as we saw with `BaseModule`, these actions are executed in **phases**. This allows you to build a reliable middleware pipeline—session handling, authentication, CORS headers, logging—where each layer is a set of actions in a distinct phase, guaranteeing their execution order.

### \#\#\# The `@request` Decorator: Topic and Method Binding

The **`@request`** decorator is the glue that binds a module's method to an incoming request. It registers the method as an action that listens for a specific request pattern. The syntax is designed to match the event topic structure generated by `BaseHttpContext`.

  * `@request('/get/users')`: Binds to a `GET` request for the `/users` path.
  * `@request('/post/users')`: Binds to a `POST` request for the `/users` path.
  * `@request('/:method/users')`: Uses a wildcard to bind to **any** HTTP method for the `/users` path. The actual method (`get`, `post`, etc.) is captured as a parameter.
  * `@request()` or `@request('/*')`: A catch-all that binds to **every single request**, regardless of method or path.

### \#\#\# Phasing and Dependencies

Just like with `@init` actions, `@request` actions are ordered by **`phase`**. An action with `phase: 20` is guaranteed to run before an action with `phase: 30`. This is the primary mechanism for ordering middleware. For actions that must run in a specific order *within the same phase*, you can still use the `@dependsOn` decorator.

-----

## How It Works: The Life of a Request

1.  **Arrival**: A `POST` request for `/api/login` hits the `http.Server` in `BaseRequestHandler`.
2.  **Routing**: The `BaseRouter` is consulted. It has no rewrite rules for this path, so it passes through unchanged.
3.  **Context & Topic Creation**: A `new BaseHttpContext` is created. It generates the topic: `/request/xyz987/post/api/login`.
4.  **Coordination**: The context calls `coordinateAndRun()` with this topic.
5.  **Action Discovery**: `BaseContext` scans its action registry for all `@request` decorators whose patterns match the topic. It might find several actions across different modules.
6.  **Phased Execution**: The context groups the discovered actions by their `phase` number and executes them in sequential order.
      * **Phase 20**: It finds an action from `SessionModule` decorated with `@request({ topic: '/*', phase: 20 })`. It runs this action to initialize a session. The context waits for all Phase 20 actions to complete.
      * **Phase 30**: It finds an action from `AuthModule` decorated with `@request({ topic: '/*, phase: 30 })`. It runs this action to check for an auth token in the now-established session.
      * **Phase 100**: Finally, it finds the main handler in `UserModule` decorated with `@request({ topic: '/post/api/login', phase: 100 })`.
7.  **Business Logic**: The `login` action in `UserModule` runs, performs the login, and accesses the session data prepared by the earlier phases.
8.  **Response**: The action calls `context.res.json({ status: 'ok' })` to send the response. The request lifecycle is complete. If at any point no handler is found for a request, `BaseHttpContext` sends a `404 Not Found`.

-----

## Example: Building a Middleware Chain with Phasing

This is the most powerful application of the request handling system. Here’s how you would ensure session initialization happens before authentication checks on every request.

#### Step 1: The Session Module (Early Phase)

This module attaches a session object to the context for every request. It needs to run first.

```typescript
// src/modules/session.ts
import { baseModule, BaseModule } from '../core/module';
import { request, BaseHttpActionArgs } from '../core/requestHandler';

@baseModule
export class SessionModule extends BaseModule {

    @request({ phase: 20 }) // Run in an early phase for ALL requests
    async attachSession(args: BaseHttpActionArgs) {
        this.logger.info("Attaching session...", [args.context.id]);
        // In a real app, you'd load or create a session here
        args.context.data.session = { id: 'session-123', user: null };
    }
}
```

#### Step 2: The Auth Module (Later Phase)

This module checks for authentication. It runs *after* the session is guaranteed to exist.

```typescript
// src/modules/auth.ts
import { baseModule, BaseModule } from '../core/module';
import { request, BaseHttpActionArgs } from '../core/requestHandler';

@baseModule
export class AuthModule extends BaseModule {

    // Runs after the SessionModule's phase
    @request({ topic: '/*', phase: 30 })
    async checkAuth(args: BaseHttpActionArgs) {
        this.logger.info("Checking authentication...", [args.context.id]);
        
        // This relies on `attachSession` having already run
        const session = args.context.data.session;
        if (!session.user) {
            this.logger.warn("Request is not authenticated.", [args.context.id]);
        }
        // If auth failed, you could end the request here:
        // args.context.res.statusCode(401).send("Unauthorized");
    }
}
```

This phased approach provides a clean, robust, and dependency-free way to build complex request-processing pipelines.

-----

## Key Components

| Component | File(s) | Role |
| :--- | :--- | :--- |
| **`BaseRequestHandler`** | `baseRequestHandler.ts` | The main server entry point. Creates the `http.Server` and hands requests off to a `BaseHttpContext`. |
| **`BaseRouter`** | `baseRouter.ts` | A URL pattern matcher and rewriter that can alter request paths before they are processed by the context. |
| **`BaseHttpContext`** | `httpContext.ts` | The bridge. Translates an HTTP request into a structured event topic (e.g., `/request/id/get/path`) and orchestrates the phased execution of handler actions. |
| **`BaseRequest`** | `baseRequest.ts` | A wrapper around the incoming request that simplifies accessing headers, cookies, and the request body. |
| **`BaseResponse`** | `baseResponse.ts` | A wrapper around the server response that provides convenient methods for sending data (`json`, `html`, etc). |
| **`@request`** | `decorators/request.ts` | The decorator that binds a module action to a request topic pattern. The key to creating handlers and middleware. |
| **`types.ts`** | `types.ts` | Contains shared type definitions, configuration classes, and the `HttpContextData` interface for sharing data between actions. |